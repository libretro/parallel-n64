Проблемы с эмуляцией фрейм буфера.

Zelda MM:
проверка на то, что содержимое буфера заполнено pBuffer->fillcolor обламывается на экране паузы.
Причина: Кадр копируется в буфер, который с начале отрисовки используется под depth buffer и чистится 0xfffcfffc.
Программа между вызовами dysplay list что-то сама пишет в этот буфер (выставляет alpha в 1), и на следующем кадре
проверка не срабатывает.

detect fb final results: 
rdp.frame_buffers[0].status = ci_main, addr: 00000500, height: 0
rdp.frame_buffers[1].status = ci_zimg, addr: 00383ac0, height: 240
rdp.frame_buffers[2].status = ci_main, addr: 00000500, height: 240
rdp.frame_buffers[3].status = ci_main, addr: 00000500, height: 240
rdp.frame_buffers[4].status = ci_main, addr: 00000500, height: 240
rdp.frame_buffers[5].status = ci_main, addr: 00000500, height: 240
rdp.frame_buffers[6].status = ci_copy, addr: 00383ac0, height: 240
rdp.frame_buffers[7].status = ci_main, addr: 00000500, height: 240
rdp.frame_buffers[8].status = ci_aux, addr: 00784600, height: 240
rdp.frame_buffers[9].status = ci_main, addr: 00000500, height: 240
rdp.frame_buffers[10].status = ci_main, addr: 00000500, height: 240
DetectFrameBufferUsage End

detect fb final results: 
rdp.frame_buffers[0].status = ci_main, addr: 00000500, height: 240
rdp.frame_buffers[1].status = ci_main, addr: 00000500, height: 240
rdp.frame_buffers[2].status = ci_main, addr: 00000500, height: 240
rdp.frame_buffers[3].status = ci_main, addr: 00000500, height: 240
DetectFrameBufferUsage End

Решение: проверять только 16бит буфер и без альфа бита.


Zelda OOT:
Та же проблема с экраном паузы, что в Zelda MM
К тому же экран не работает если включен subscreen fix!


Mario Tennis:
Scoreboard. Таблица счёта и датчик скорости подачи выглядят как чёрный фон с текстом.
Причина: текстуры таблицы и датчика грузятся в память. Текста в них нет, пустые области.
Мы видим эти текстуры при отключенной эмуляции буфера кадра. Когда нужно обновить текст,
игра заводит вспомогательный буфер кадра по адресу, где лежит текстура, и рендит текст в нужных местах.
Потом текстура с текстом накладывается на полигоны таблицы. Так как адрес буфера совпадает с адресом текстуры,
буфер используется вместо нее, а в нем только текст.
Решение: после отрисовки копировать содержимое буфера обратно в RDRAM. Нужно найти нормальное условие для
определения такого буфера. Пока адреса буферов захардкоданы.

F1 Pole Position:
Проблемы с фоном в меню. После титров запускается демо с 3D моделями. Используется буфер глубины.
Пре переходе снова к меню тектуры фона грузятся в область, которая использовалась под z буфер.
У буфера флаг cleared сброшен после записи z буфера в RDRAM, проверка валидности не находит проблем. и тектура
грузится из пустого буфера.

Решение: Depth copy to RDRAM записывает checksum записанных данных в буфер, соотвествующий буферу глубины.
Тогда в дальнейшем проверка по checksum удалит этот буфер.
Upd: Решение плохое. Ломает subscreen in Zelda OOT. Игра меняет область z буфера (выставляет alpha = 1) когда использует его как фон для
экрана паузы. Checksum не бъет. Решение - разделить опции hack_noDepthFrameBuffers и hack_blurPauseScreen
Для этой игры включить hack_noDepthFrameBuffers и просто убирать буфер глубины при попытке считать из него текстуру.


Mickey's Speedway USA:
pause screen работает так: в область текущего буфера глубины копируется буфер кадра, который в данный момент отображаетс я на экране.
Далее этот буфер размывается на уровне CPU и потом используется как текстура. Подобный механизм работает в Conker BFD.
Чтобы получить размытие нужно копировать буфер кадра в RDRAM, а в момент вызова паузы скопировать его (memcopy) в
буфер глубины в RDRAM. При этом нужно чтобы эта область не очистилась через gDPFillRDRAM при смене буфера.
Для починки отключил вызов gDPFillRDRAM если m_isDepthBuffer == true.


Jet Force Gemini:
Обнаружилась проблема с вспомогательным 8бит буфером для теней. Буфер создается отдельным display list'ом.
Буфер создается, очищается fillrect, стоит флаг cleared. После этого игра пишет пару байт в середине буфера, и
в следующем display list, где буфер используется, проверка по RDRAM не срабатывает.

Пришлось сделать проверку не строгой, а отсекать если количество ошибочных пикселов в буфере меньше порогового значения.
Пока сделал порог в 1%.

Pokemon Stadium 2:
Возникла проблема с портретами покемонов. Портреты создаются в вспомогательных буферах когда на экране отображается
меню выбора покемонов. В этот момент работает interlaced видео режим. Потом игра переключается в режим битвы,
и переключает видео режим в non-interlaced. При переключениии режимов все буферы сбрасывались и портреты терялись.

Пришлось сделать сброс только для полноэкранных буферов.

Pokemon Stadium:
Игра использует кучу вспомогательных буферов для отрисовки меню. При этом буфера могут иметь одинаковую ширину, но разную
высоту. И располагаться друг за другом. Код, который проверяет пересечение нового буфера с существующими и выбрасывает все
пересекающиеся буфера, в данном случае выкидывал большую часть буферов из за неверно проставленной высоты, а значит и 
нижнего адреса буфера.

Пришлось править код коррекции высоты буфера, и вызывать метод поиска пересечений после коррекции.


Blast Corps:
Возникла проблема с depth image, которая приводила к остановке видео драйвера. Игра создавала вспомогательный depth image
для вспомогательного color image. Адрес вспомогательного depth image совпадал с адресом основного, но ширина ставилась такая же
как у вспомогательного color image. Из-за последовательности команд плагин не вовремя просекал изменение размеров depth image,
что приводило к установке неверного depth buffer для FBO и к краху драйвера.

Решение: При вызове setcolorimage, если color image == depth image, вызывать depthBufferList().saveBuffer, который
при необходимости пересоздаст depth buffer.
